using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace DM_RGR_N1
{
    class Program
    {
        static void Main(string[] args)
        {
            int p = 0, q = 0, i, j, k, n, d = 0; //необходимые переменные
            Console.WriteLine("\nГраф G(p, q)\n\nВведите p");
            p = Convert.ToInt16(Console.ReadLine()); //считываем p - кол-во вершин
            Console.WriteLine("\nВведите q");
            q = Convert.ToInt16(Console.ReadLine()); //считываем q - кол-во дуг

            int[,] A = new int[p, p]; //массив для матрицы смежности
            int[,] B = new int[p, p]; //массив для хранения матрицы смежности в степени n-1
            int[,] C = new int[p, p]; //массив для хранения матрицы смежности в степени n
            List<int> distance = new List<int>(); //список для хранения расстояний между заданной парой вершин

            Console.WriteLine("\nВведите(построчно) матрицу смежности графа G");
            for(i = 0; i < p; i++) //вводим матрицу смежности исходного графа
            {
                string s = "";
                s = Console.ReadLine(); //считываем строку s
                s = s.Replace(" ", ""); //уничтожаем пробелы в строке s
                for (j = 0; j < s.Length; j++) //строку s заносим в массив(посимвольно)
                    A[i, j] = int.Parse(Convert.ToString(s[j]));
                //переводим символ строки в строку, чтобы затем получить сам символ, а не его код
            }

            int l = q - p + 3; //длина маршрута
            C = A; //дублируем массив А в С, чтобы дальнейший цикл был работоспособным
            for (n = 1; n < l; n++) //степень возведения
            {
                B = C; //дублируем массив С в В
                C = new int[p, p]; //очищаем массив С для дальнейшего его использования
                for (i = 0; i < p; i++) //строки
                {
                    for (j = 0; j < p; j++) //столбцы
                    {
                        for (k = 0; k < p; k++) //строки второй матрицы(для умножения матриц)
                            C[i, j] = C[i, j] + A[i, k] * B[k, j]; //получаем массив С при умножении массивов(матриц) А и В
                    }
                }
            }
            Console.WriteLine("\nКоличество маршрутов длины q-p+3("+ l +") между вершинами 1 и 2: " + C[0, 1] + "\n");
            /*вычислили массив С(матрица смежности возведенная в степень q-p+3), поэтому можно получить
             * количество маршрутов длины q-p+3 между вершинами 1 и 2 в столбце 1, строке 2 матрицы С*/

            for (i = 0; i < p; i++) //для удобства, выводим матрицу С
            {
                for (j = 0; j < p; j++)
                    Console.Write(C[i, j] + " "); //выводим значение
                Console.WriteLine(); //переводим строку
            }

            void distanceSearch(int a, int b, int d1, int y) //рекурсивный метод для нахождения расстояния между вершинами
                //аргументы: строка для сравнения, столбец для сравнения, расстояние между вершинами, столбец, с которого начинается сравнение
            {
                if (A[a, b] == 1) //проверяем на совпадение 
                {
                    distance.Add(d1); //записываем расстояние в список
                    return;
                }
                else
                {
                    for (int x = y; x < p; x++) //пробегаемся по значениям строки а со столбца y
                    {
                        if (A[a, x] == 1)
                            distanceSearch(x, b, d1 + 1, x);
                        //производим повторное вхождение в метод, изменяя при это границу поиска и расстояние
                    }
                }
            }

            distanceSearch(3, 5, 1, 0); //вызываем метод поиска кратчайшего расстояния между вершинами 4 и 6
            //после рекурсивного выполнения метода, будет получено расстояние
            Console.WriteLine("\nРасстояние(кратчайшее) между вершинами 4 и 6: " + distance.Min() + "\n");

            Console.ReadKey();
        }
    }
}
